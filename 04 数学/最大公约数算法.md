> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/451041897)

**前言**
------

> 这个章节，我们将学习数论里面重要内容 —— 最大公约数。在学习它之前，首先需要了解模运算的运算法则。

**一、模运算**
---------

    给定一个正整数 $p$，任意一个整数 $n$，一定存在等式 $n = kp + r$； 其中 、$k、r$  是整数，且满足 $0 \le r \lt p$，称 $k$ 为 $n$ 除以 $p$ 的商， $r$ 为 $n$ 除以 $p$ 的余数，表示成 $n \% p = r$ (这里采用 C++ 语法，% 表示取模运算)。  
    对于正整数和整数 $a$, $b$, 定义如下运算：

**二、朴素法求最大公约数**
---------------

    我可以从大到小枚举 $a$ 的约数，然后再判断它是不是 $b$ 的约数，就能找到最大的那个满足条件的约数，就是所求 $gcd$ 了。算法实现如下：

```C++
int gcd(int a, int b) {
    int i;
    for(i = a; i >= 2; --i) {
        if(a % i == 0 && b % i == 0)
            return i;
    }
    return 1;
}
```

    这个算法的时间复杂度是 $O(n)$ 的，算法效率较低，所以，我们需要更加高效的算法。

**三、辗转相除法求最大公约数**
-----------------

$$gcd(a,b) = \begin{cases} a & b=0\\ gcd(b, a \ mod \ b) & b \neq 0 \end{cases} \\$$

写成代码，就是：

```C++
int gcd(int a, int b) {
    return !b ? a : gcd(b, a % b);
}
```

    这里 `!`是 c/c++ 中的表达式取非的意思，即 真变假，假变真，且 c/c++ 中 0 为假，非 0 为真；`%`是取模，即 $mod$ 的程序语法。这个算法的时间复杂度为 $O(log_2n)$ 。
